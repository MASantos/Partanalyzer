<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Partanalyzer: Partition class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>Partition Class Reference</h1><code>#include &lt;<a class="el" href="Partition_8h-source.html">Partition.h</a>&gt;</code>
<p>
<a href="classPartition-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a0">Partition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Partition constructor. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="Partition::Partition"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a1">Partition</a> (char *file, partFileFormat iformat=partFmtPART, int ofs=2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiate partition from file using format iformat and specified offset (applies only to partanalyzer's own format partFmtPART). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="Partition::Partition"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a2">Partition</a> (smat *clustersl, int ofs, bool dosort=true, char *partf=NULL, char *tabf=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a partition out of a set of clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a3">Partition</a> (set&lt; sset * &gt; sclassp, int ofs=2, char *partf=NULL, char *tabf=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a4" doxytag="Partition::summary"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a4">summary</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print summary of most import facts. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="Partition::xtractElements"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a5">xtractElements</a> (svect *elements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract selected elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="Partition::xtrConsPart"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a6">xtrConsPart</a> (multimap&lt; int, string, <a class="el" href="structgreaterThan.html">greaterThan</a> &gt; consPart, int ofs=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a consensus partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a7" doxytag="Partition::getItems"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a7">getItems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get (and reset) the underlying set of elements sorted by alphanumerically. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="Partition::getItems"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a8">getItems</a> (cluster *cl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an ordered set with all elements contained in (svect) cl. {Doesn't affect Partition; should be external maybe}. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a9">isaPartitionOf</a> (svect &amp;ssetOfElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check it is a sound Partition of the specified set of elements. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="Partition::isaPartition"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a10">isaPartition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check it is a sound Partition of the default set of elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="Partition::printPartition"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a11">printPartition</a> (bool SequentialClusterNames=false, string ClusterPrefix="C")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print partition using the default partanalyzer format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="Partition::printPartition"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a12">printPartition</a> (partFileFormat iformat, bool SequentialClusterNames=false, string ClusterPrefix="C")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print partition in the specified format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a13" doxytag="Partition::n_clusters"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a13">n_clusters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of clusters (including singletons). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="Partition::n_singletons"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a14">n_singletons</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of singletons. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a15" doxytag="Partition::n_pairs"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a15">n_pairs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of pair clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="Partition::n_nonSingClusters"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a16">n_nonSingClusters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of non-singletons clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a17" doxytag="Partition::n_items"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a17">n_items</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a18" doxytag="Partition::cluster_offset"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a18">cluster_offset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get cluster offset (used only with partanalyzer's own format partFmtPART). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a19" doxytag="Partition::largest_Cluster"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a19">largest_Cluster</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get index of largest cluster in (smat) Partition::smat. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a20" doxytag="Partition::it_largest_Cluster"></a>
smat::iterator&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a20">it_largest_Cluster</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get iterator pointing to largest cluster in (smat) Partition::smat. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a21" doxytag="Partition::setPartInputFormat"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a21">setPartInputFormat</a> (partFileFormat iformat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set partition input file format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a22" doxytag="Partition::getPartInputFormat"></a>
partFileFormat&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a22">getPartInputFormat</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve partition input file format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a23" doxytag="Partition::mclTabFile"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a23">mclTabFile</a> (char *mcltabf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load MCL tab file. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a24" doxytag="Partition::tabFile"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a24">tabFile</a> (char *tabf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a general tab file for changing name of elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a25" doxytag="Partition::swapLabels"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a25">swapLabels</a> (char *mcltabf=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap labels according to the provided tab file. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a26" doxytag="Partition::H"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a26">H</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entropy of a partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a27" doxytag="Partition::card"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a27">card</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cardinality of a partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a28" doxytag="Partition::BK"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a28">BK</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Boltzman Entropy: log (#available states). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="Partition::TS"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a29">TS</a> (double q=EXTENSIVITY_DEFAULT_TSALLIS)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tsallis Entropy: is equal to H iif q=1 ; q=non-extensivity coefficient. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a30" doxytag="Partition::RS"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a30">RS</a> (double q=EXTENSIVITY_DEFAULT_RENYI)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renyi Entropy: is equal to H iif q=1 ; q=non-extensivity coefficient. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a31" doxytag="Partition::JQnorm"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a31">JQnorm</a> (double q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the Jeffrey Qnorm (a la Tarantola) of a partition= exp(RS(q)) or expr(TS(q)). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a32">vipp</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates and prints vi distance againts given partition part2. </em> <a href="#a32"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a33" doxytag="Partition::edsc"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a33">edsc</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates and prints edit score distance againts given partition part2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a34" doxytag="Partition::td"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a34">td</a> (<a class="el" href="classPartition.html">Partition</a> *part2, double q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the Tarantola distance against given partition part2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a35" doxytag="Partition::purityStrict"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a35">purityStrict</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the purity strict values againts the given partition p2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a36" doxytag="Partition::purityLax"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a36">purityLax</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the purity lax values againts the given partition p2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a37">purityScore</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates both purity score values againts the given partition p2. </em> <a href="#a37"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a38" doxytag="Partition::missing"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>missing</b> (svect *items_found)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a39" doxytag="Partition::missing"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>missing</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a40" doxytag="Partition::getClusterSize"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a40">getClusterSize</a> (const string &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an element, get the size of the cluster that contains it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a41" doxytag="Partition::getClusterName"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a41">getClusterName</a> (string &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an element, get the name of the cluster that contains it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a42" doxytag="Partition::getClusterName"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a42">getClusterName</a> (int &amp;clidx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an index from clusters, get the name of that cluster. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a43" doxytag="Partition::getClusterName"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a43">getClusterName</a> (svect &amp;cluster)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given the cluster, get its name. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a44" doxytag="Partition::getClusterIdx"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a44">getClusterIdx</a> (string &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an element, get the index of the cluster that contains it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a45" doxytag="Partition::areEquiv"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a45">areEquiv</a> (string a, string b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two elements are equivalent if they belong to the same cluster. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a46" doxytag="Partition::areWithinSameCluster"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a46">areWithinSameCluster</a> (string ita, string itb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return name of cluster if true; x if false ; NAN1 (NAN2) if first (second) not found. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a47" doxytag="Partition::FileName"></a>
char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a47">FileName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the filename. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a48" doxytag="Partition::getClusterOf"></a>
svect&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a48">getClusterOf</a> (string item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">cluster is a typedef specific for Partition <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a49" doxytag="Partition::setAdjacencyMatrix"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a49">setAdjacencyMatrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build associated Adjacency matrix. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a50" doxytag="Partition::setAdjacencyMatrix_os"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a50">setAdjacencyMatrix_os</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build associated Adjacency matrix sorting elements by clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a51" doxytag="Partition::Ad"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a51">Ad</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get AdjacencyMatrix. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a52" doxytag="Partition::Ad_os"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a52">Ad_os</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get AdjacencyMatrix with indexes ordered as given by the partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a53" doxytag="Partition::SubsProject"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a53">SubsProject</a> (sset &amp;itemset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Project a Partition of N elements onto a subspace of M&lt;=N elements (active view). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a54">intersection</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the partition intersection of the present one and part2 (passed by pointer). </em> <a href="#a54"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a55" doxytag="Partition::intersection"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a55">intersection</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the partition intersection of the present one and part2 (passed by reference). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a56" doxytag="Partition::lessThan"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a56">lessThan</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define Lattice preorder relation (as an interface). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a57" doxytag="Partition::operator<="></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a57">operator&lt;=</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define Lattice preorder relation (as a binary operator). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a58" doxytag="Partition::operator<"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a58">operator&lt;</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define lattice strict preorder relation (as a binary operator). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a59" doxytag="Partition::operator=="></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a59">operator==</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define equality operater. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a60" doxytag="Partition::operator *"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a60">operator *</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define intersetion of partitions ( as a binary operator ; arguments as refereces). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a61" doxytag="Partition::operator *"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a61">operator *</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define intersetion of partitions ( as a binary operator ; arguments as pointers). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a62">operator+</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">(TO BE IMPLEMENTED) Define union of partitions (as a binary operator) </em> <a href="#a62"></a><em><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="o0" doxytag="Partition::clusters"></a>
smat&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#o0">clusters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of clusters, each being a svect containing number of elements, name of cluster, and all its elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="o1" doxytag="Partition::sitems"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#o1">sitems</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set of elements (treated as strings; represents the underlying set of elements). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="o2" doxytag="Partition::ssingletons"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#o2">ssingletons</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorted set of singleton elements. <br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Main class Partition implements a partition and its algebra 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="Partition::Partition"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Partition::Partition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default Partition constructor. 
<p>
Let's make sure we do not get any duplicated singleton. This is just a cheap patch for trying to speed up <a class="el" href="classPartition.html#a10">isaPartition()</a>.     </td>
  </tr>
</table>
<a name="a3" doxytag="Partition::Partition"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Partition::Partition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">set&lt; sset * &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>sclassp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ofs</em> = 2, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>partf</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tabf</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a partition out of a set of pointers to sets (let's call that classes: so a set of pointers to classes...) Partition _will_ be sorted by size of clusters and also within each cluster automatically.    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a54" doxytag="Partition::intersection"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classPartition.html">Partition</a> Partition::intersection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the partition intersection of the present one and part2 (passed by pointer). 
<p>
Will contain intersection between cla and clb<p>
Set its size and name. These will be its first two entries<p>
First, the name of the cluster<p>
the name of the cluster<p>
Second, the size of the cluster<p>
Second, the size of the cluster<p>
Third, the fake reverse-sorting label<p>
Third, the fake reverse-sorting label<p>
Reverse sort : Larger clusters firstl singletons last<p>
REmove the first fake reverse-sorting label of each cluster<p>
pointer refering to largest cluster     </td>
  </tr>
</table>
<a name="a9" doxytag="Partition::isaPartitionOf"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Partition::isaPartitionOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">svect &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>svecOfelements</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check it is a sound Partition of the specified set of elements. 
<p>
One single clusters does make a sound partitions<p>
For the moment, lets assume clusters are not ordered in descending order by size<p>
SKIP check for singletons, but non-singletons ARE checked againts clb singletons!!<p>
With the introduction of <a class="el" href="classPartition.html#o2">Partition::ssingletons</a>, no instantiated Partition can have the same singleton element more than once. Hence, there is no need in checking singletons againts singletons. Looping over them means that, on an Opteron 846 2GH, it takes 15sec to check a partition with 502 elements and on average 185 clusters and 95 singletons. Does skipping singletons helps to significantly improve this figure? Also, take svect cla= clusters[i]; out of the second loop (that was weird!). Ok, preliminary test shows an increase in speed of ~28%, i.e, 9.5sec/partition now versus 13.2sec before! (Compared both ways using a set of 19 partitions of those same sizes.     </td>
  </tr>
</table>
<a name="a62" doxytag="Partition::operator+"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classPartition.html">Partition</a> Partition::operator+ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
(TO BE IMPLEMENTED) Define union of partitions (as a binary operator) 
<p>
Start of largest cluster in this<p>
and end.<p>
extract only the elements, i.e., w/o the labels.<p>
Start of largest cluster in [art2<p>
and its end.<p>
extract only the elements, i.e., w/o the labels.<p>
First join the two largest clusters     </td>
  </tr>
</table>
<a name="a37" doxytag="Partition::purityScore"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; double &gt; Partition::purityScore </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates both purity score values againts the given partition p2. 
<p>
Normalize by the reference partition<p>
Normalize by the target partition     </td>
  </tr>
</table>
<a name="a32" doxytag="Partition::vipp"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Partition::vipp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates and prints vi distance againts given partition part2. 
<p>
For each cluster cla and<p>
clb , find the <p>
number of items they have in common.<p>
VI make sense only if number items is equeal.<p>
Using the same normalization for both entropies<p>
Using the same normalization for both entropies<p>
is tantamout to assuming each item from partition1 not present in partition2 is a singleton in partition2     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Partition_8h-source.html">Partition.h</a><li>Partition.cc</ul>
<hr size="1"><address style="align: right;"><small>Generated on Wed Feb 10 11:33:43 2010 for Partanalyzer by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
