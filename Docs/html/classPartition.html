<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Partanalyzer: Partition class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>Partition Class Reference</h1>Main class Partition implements a partition and its algebra.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="Partition_8h-source.html">Partition.h</a>&gt;</code>
<p>
<a href="classPartition-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a0">Partition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Partition constructor. </em> <a href="#a0"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="Partition::Partition"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a1">Partition</a> (char *file, partFileFormat iformat=partFmtPART, int ofs=2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Instantiate partition from file using format iformat and specified offset (applies only to partanalyzer's own format partFmtPART). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="Partition::Partition"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a2">Partition</a> (smat *clustersl, int ofs, bool dosort=true, char *partf=NULL, char *tabf=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a partition out of a vector of clusters (the latter being svect). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a3">Partition</a> (set&lt; sset * &gt; sclassp, int ofs=2, char *partf=NULL, char *tabf=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a4" doxytag="Partition::setMatrixOfValues"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a4">setMatrixOfValues</a> (char *file, int col=EDGES_DEFAULT_COLUMN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> based on external file. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="Partition::resetMatrixOfValues"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a5">resetMatrixOfValues</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set <a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> to default Identity matrix. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="Partition::summary"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a6">summary</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print summary of most import facts. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a7" doxytag="Partition::xtractElements"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a7">xtractElements</a> (svect *elements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Extract selected elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a8" doxytag="Partition::xtrConsPart"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a8">xtrConsPart</a> (multimap&lt; int, string, <a class="el" href="structgreaterThan.html">greaterThan</a> &gt; consPart, int ofs=1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a consensus partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a9" doxytag="Partition::getItems"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a9">getItems</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get (and reset) the underlying set of elements sorted by alphanumerically. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="Partition::getItems"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a10">getItems</a> (cluster *cl)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get an ordered set with all elements contained in (svect) cl. {Doesn't affect Partition; should be external maybe}. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a11">isaPartitionOf</a> (svect &amp;ssetOfElements)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check it is a sound Partition of the specified set of elements. </em> <a href="#a11"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="Partition::isaPartition"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a12">isaPartition</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check it is a sound Partition of the default set of elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a13" doxytag="Partition::isPartitionONE"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a13">isPartitionONE</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if it is a Partition containing 1 single cluster, i.e., partition 1. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="Partition::isPartitionZERO"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a14">isPartitionZERO</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if it is a Partition containing all singletons, i.e., partition 0. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a15" doxytag="Partition::print"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a15">print</a> (bool SequentialClusterNames=false, string ClusterPrefix="C")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print partition using the default partanalyzer format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="Partition::print"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a16">print</a> (partFileFormat iformat, bool SequentialClusterNames=false, string ClusterPrefix="C")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print partition in the specified format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a17" doxytag="Partition::printPartition"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a17">printPartition</a> (bool SequentialClusterNames=false, string ClusterPrefix="C")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print partition using the default partanalyzer format ( DEPECRATED: Use print(...) instead ). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a18" doxytag="Partition::printPartition"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a18">printPartition</a> (partFileFormat iformat, bool SequentialClusterNames=false, string ClusterPrefix="C")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print partition in the specified format ( DEPECRATED: Use print(...) instead ). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a19" doxytag="Partition::n_clusters"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a19">n_clusters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of clusters (including singletons). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a20" doxytag="Partition::n_singletons"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a20">n_singletons</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of singletons. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a21" doxytag="Partition::n_pairs"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a21">n_pairs</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of pair clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a22" doxytag="Partition::n_nonSingClusters"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a22">n_nonSingClusters</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of non-singletons clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a23" doxytag="Partition::n_items"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a23">n_items</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a24" doxytag="Partition::cluster_offset"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a24">cluster_offset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get cluster offset (used only with partanalyzer's own format partFmtPART). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a25" doxytag="Partition::largest_Cluster"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a25">largest_Cluster</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get index of largest cluster in (smat) Partition::smat. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a26" doxytag="Partition::it_largest_Cluster"></a>
smat::iterator&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a26">it_largest_Cluster</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get iterator pointing to largest cluster in (smat) Partition::smat. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a27" doxytag="Partition::setPartInputFormat"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a27">setPartInputFormat</a> (partFileFormat iformat)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set partition input file format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a28" doxytag="Partition::getPartInputFormat"></a>
partFileFormat&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a28">getPartInputFormat</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve partition input file format. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a29" doxytag="Partition::mclTabFile"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a29">mclTabFile</a> (char *mcltabf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load MCL tab file. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a30" doxytag="Partition::tabFile"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a30">tabFile</a> (char *tabf)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Load a general tab file for changing name of elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a31" doxytag="Partition::swapLabels"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a31">swapLabels</a> (char *mcltabf=NULL)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap labels according to the provided tab file. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a32" doxytag="Partition::H"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a32">H</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Entropy of a partition (Shannon). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a33" doxytag="Partition::wH"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a33">wH</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Weighted (Shannon) Entropy of a partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a34" doxytag="Partition::card"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a34">card</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cardinality of a partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a35" doxytag="Partition::BK"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a35">BK</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Boltzman Entropy: log (#available states). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a36" doxytag="Partition::TS"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a36">TS</a> (double q=EXTENSIVITY_DEFAULT_TSALLIS)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Tsallis Entropy: is equal to H iif q=1 ; q=non-extensivity coefficient. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a37" doxytag="Partition::RS"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a37">RS</a> (double q=EXTENSIVITY_DEFAULT_RENYI)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Renyi Entropy: is equal to H iif q=1 ; q=non-extensivity coefficient. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a38" doxytag="Partition::JQnorm"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a38">JQnorm</a> (double q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the Jeffrey Qnorm (a la Tarantola) of a partition= exp(RS(q)) or expr(TS(q)). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a39">vipp</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates and prints vi distance againts given partition part2. </em> <a href="#a39"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a40" doxytag="Partition::edsc"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a40">edsc</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates and prints edit score distance againts given partition part2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a41" doxytag="Partition::td"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a41">td</a> (<a class="el" href="classPartition.html">Partition</a> *part2, double q)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the Tarantola distance against given partition part2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a42" doxytag="Partition::purityStrict"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a42">purityStrict</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the purity strict values againts the given partition p2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a43" doxytag="Partition::purityLax"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a43">purityLax</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates the purity lax values againts the given partition p2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>vector&lt; double &gt;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a44">purityScore</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculates both purity score values againts the given partition p2. </em> <a href="#a44"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a45" doxytag="Partition::missing"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>missing</b> (svect *items_found)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a46" doxytag="Partition::missing"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>missing</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a47" doxytag="Partition::getClusterName"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a47">getClusterName</a> (string &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an element, get the name of the cluster that contains it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a48" doxytag="Partition::getClusterName"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a48">getClusterName</a> (int &amp;clidx)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an index from clusters, get the name of that cluster. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a49" doxytag="Partition::getClusterName"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a49">getClusterName</a> (svect &amp;cluster)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given the cluster, get its name. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a50" doxytag="Partition::getClusterSize"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a50">getClusterSize</a> (const string &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an element, get the size of the cluster that contains it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>svect&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a51">getClusterOf</a> (string item)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a52" doxytag="Partition::getClusterIdx"></a>
int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a52">getClusterIdx</a> (string &amp;item)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Given an element, get the index of the cluster that contains it. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a53" doxytag="Partition::areEquiv"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a53">areEquiv</a> (string a, string b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Two elements are equivalent if they belong to the same cluster. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a54" doxytag="Partition::areWithinSameCluster"></a>
string&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a54">areWithinSameCluster</a> (string ita, string itb)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return name of cluster if true; x if false ; NAN1 (NAN2) if first (second) not found. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a55" doxytag="Partition::FileName"></a>
char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a55">FileName</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the filename. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a56" doxytag="Partition::setAdjacencyMatrix"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a56">setAdjacencyMatrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build associated Adjacency matrix. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a57" doxytag="Partition::setAdjacencyMatrix_os"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a57">setAdjacencyMatrix_os</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Build associated Adjacency matrix sorting elements by clusters. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a58" doxytag="Partition::Ad"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a58">Ad</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get AdjacencyMatrix. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a59" doxytag="Partition::Ad_os"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a59">Ad_os</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get AdjacencyMatrix with indexes ordered as given by the partition. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a60" doxytag="Partition::SubsProject"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a60">SubsProject</a> (sset &amp;itemset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Project a Partition of N elements onto a subspace of M&lt;=N elements (active view). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a61">intersection</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the partition intersection of the present one and part2 (passed by pointer). </em> <a href="#a61"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a62" doxytag="Partition::intersection"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a62">intersection</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the partition intersection of the present one and part2 (passed by reference). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a63" doxytag="Partition::join"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a63">join</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the partition union of the present one and part2 (passed by pointer). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a64" doxytag="Partition::join"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a64">join</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calculate the partition union of the present one and part2 (passed by reference). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a65" doxytag="Partition::lessThan"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a65">lessThan</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define Lattice preorder relation (as an interface). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a66" doxytag="Partition::operator<="></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a66">operator&lt;=</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define Lattice preorder relation (as a binary operator). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a67" doxytag="Partition::operator<"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a67">operator&lt;</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define lattice strict preorder relation (as a binary operator). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a68" doxytag="Partition::operator=="></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a68">operator==</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define equality operater. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a69" doxytag="Partition::operator *"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a69">operator *</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define intersetion of partitions ( as a binary operator ; arguments as refereces). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a70" doxytag="Partition::operator *"></a>
<a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a70">operator *</a> (<a class="el" href="classPartition.html">Partition</a> *part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define intersetion of partitions ( as a binary operator ; arguments as pointers). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a71" doxytag="Partition::operator *="></a>
<a class="el" href="classPartition.html">Partition</a> &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a71">operator *=</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define intersetion of partitions ( as a unary operator ; arguments as refereces). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classPartition.html">Partition</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a72">operator+</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define union of partitions (as a binary operator). </em> <a href="#a72"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a73" doxytag="Partition::operator+="></a>
<a class="el" href="classPartition.html">Partition</a> &amp;&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#a73">operator+=</a> (<a class="el" href="classPartition.html">Partition</a> &amp;part2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Define union of partitions (as a unary operator). <br><br></td></tr>
<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="o0" doxytag="Partition::clusters"></a>
smat&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#o0">clusters</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Vector of clusters, each being a svect containing number of elements, name of cluster, and all its elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="o1" doxytag="Partition::sitems"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#o1">sitems</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set of elements (treated as strings; represents the underlying set of elements). <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="o2" doxytag="Partition::ssingletons"></a>
sset&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classPartition.html#o2">ssingletons</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorted set of singleton elements. <br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Main class Partition implements a partition and its algebra. 
<p>
Main class Partition implements a partition and its algebra. The latter is defined by the join (union) and meet (intersection) operations. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="Partition::Partition"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Partition::Partition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Default Partition constructor. 
<p>
Let's make sure we do not get any duplicated singleton. This is just a cheap patch for trying to speed up <a class="el" href="classPartition.html#a12">isaPartition()</a>.     </td>
  </tr>
</table>
<a name="a3" doxytag="Partition::Partition"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Partition::Partition </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">set&lt; sset * &gt;&nbsp;</td>
          <td class="mdname" nowrap> <em>sclassp</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>ofs</em> = 2, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>partf</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *&nbsp;</td>
          <td class="mdname" nowrap> <em>tabf</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a partition out of a set of pointers to sets (let's call that classes: so a set of pointers to classes...) Partition _will_ be sorted by size of clusters and also within each cluster automatically.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a51" doxytag="Partition::getClusterOf"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> svect Partition::getClusterOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">string&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>item</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Given an element, get the cluster that contains it. cluster is a typedef specific for Partition     </td>
  </tr>
</table>
<a name="a61" doxytag="Partition::intersection"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classPartition.html">Partition</a> Partition::intersection </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculate the partition intersection of the present one and part2 (passed by pointer). 
<p>
Will contain intersection between cla and clb<p>
Set its size and name. These will be its first two entries<p>
First, the name of the cluster<p>
the name of the cluster<p>
Second, the size of the cluster<p>
Second, the size of the cluster<p>
Third, the fake reverse-sorting label<p>
Third, the fake reverse-sorting label<p>
Reverse sort : Larger clusters firstl singletons last<p>
REmove the first fake reverse-sorting label of each cluster<p>
pointer refering to largest cluster     </td>
  </tr>
</table>
<a name="a11" doxytag="Partition::isaPartitionOf"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool Partition::isaPartitionOf </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">svect &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>svecOfelements</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check it is a sound Partition of the specified set of elements. 
<p>
One single clusters does make a sound partitions<p>
For the moment, lets assume clusters are not ordered in descending order by size<p>
SKIP check for singletons, but non-singletons ARE checked againts clb singletons!!<p>
With the introduction of <a class="el" href="classPartition.html#o2">Partition::ssingletons</a>, no instantiated Partition can have the same singleton element more than once. Hence, there is no need in checking singletons againts singletons. Looping over them means that, on an Opteron 846 2GH, it takes 15sec to check a partition with 502 elements and on average 185 clusters and 95 singletons. Does skipping singletons helps to significantly improve this figure? Also, take svect cla= clusters[i]; out of the second loop (that was weird!). Ok, preliminary test shows an increase in speed of ~28%, i.e, 9.5sec/partition now versus 13.2sec before! (Compared both ways using a set of 19 partitions of those same sizes.     </td>
  </tr>
</table>
<a name="a72" doxytag="Partition::operator+"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classPartition.html">Partition</a> Partition::operator+ </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Define union of partitions (as a binary operator). 
<p>
Offset of part2<p>
Will contain the set of pair-wise disjoint clusters defining the union<p>
pitemsset is a pointer to the largest set of items between the two partitions<p>
For each element of the underlying set, obtain the union of its 2 clusters from both partitions<p>
If cla fills completely the set of elements, we are done. Build a partition with it (partition 1) and return<p>
If cla is not the first element, remove the previous one if it's already contained within cla<p>
While cla is not the last element, remove it if it's already contained within next one     </td>
  </tr>
</table>
<a name="a44" doxytag="Partition::purityScore"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> vector&lt; double &gt; Partition::purityScore </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates both purity score values againts the given partition p2. 
<p>
Normalize by the reference partition<p>
Normalize by the target partition     </td>
  </tr>
</table>
<a name="a39" doxytag="Partition::vipp"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void Partition::vipp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classPartition.html">Partition</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>part2</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Calculates and prints vi distance againts given partition part2. 
<p>
For each cluster cla and<p>
clb , find the <p>
number of items they have in common.<p>
VI make sense only if number items is equeal.<p>
Using the same normalization for both entropies<p>
Using the same normalization for both entropies<p>
is tantamout to assuming each item from partition1 not present in partition2 is a singleton in partition2     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="Partition_8h-source.html">Partition.h</a><li>Partition.cc</ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Feb 19 17:36:31 2010 for Partanalyzer by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
