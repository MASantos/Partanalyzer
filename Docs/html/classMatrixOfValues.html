<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Partanalyzer: MatrixOfValues class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="annotated.html">Compound&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Compound&nbsp;Members</a></div>
<h1>MatrixOfValues Class Reference</h1><code>#include &lt;<a class="el" href="MatrixOfValues_8h-source.html">MatrixOfValues.h</a>&gt;</code>
<p>
<a href="classMatrixOfValues-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a0" doxytag="MatrixOfValues::MatrixOfValues"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a0">MatrixOfValues</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Constructor. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a1" doxytag="MatrixOfValues::MatrixOfValues"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a1">MatrixOfValues</a> (char *file, int col=EDGES_DEFAULT_COLUMN)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor based on a file. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a2" doxytag="MatrixOfValues::MatrixOfValues"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a2">MatrixOfValues</a> (graph Graph)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructor based on a graph. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a3" doxytag="MatrixOfValues::MatrixOfValues"></a>
&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a3">MatrixOfValues</a> (const <a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> &amp;MOV)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy-constructor. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a4" doxytag="MatrixOfValues::pruneEdgesBelow"></a>
<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a4">pruneEdgesBelow</a> (float edgethreshold, bool terse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prunes all edges with weight &lt; threshold. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a5" doxytag="MatrixOfValues::pruneEdgesBelow"></a>
<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>pruneEdgesBelow</b> (float edgethreshold, long int &amp;nprunedges, bool terse=true)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a6" doxytag="MatrixOfValues::pruneEdgesAbove"></a>
<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a6">pruneEdgesAbove</a> (float edgethreshold, bool terse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prunes all edges with weight &gt; threshold. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a7" doxytag="MatrixOfValues::pruneEdgesAbove"></a>
<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a>&nbsp;</td><td class="memItemRight" valign=bottom><b>pruneEdgesAbove</b> (float edgethreshold, long int &amp;nprunedges, bool terse=true)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classMatrixOfValues.html">MatrixOfValues</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a8">pruneEdges</a> (float edgethreshold, long int &amp;nprunedges, bool below=true, bool terse=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Prunes all edges with weight &lt; threshold if flag is true; &gt; threshold otherwise. </em> <a href="#a8"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>Partition&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a9">cluster</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cluster graph. </em> <a href="#a9"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a10" doxytag="MatrixOfValues::reset"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a10">reset</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reset private members based on interal _graph. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a11" doxytag="MatrixOfValues::getGraph"></a>
graph&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a11">getGraph</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get underlying graph. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a12" doxytag="MatrixOfValues::FileName"></a>
char *&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a12">FileName</a> () const</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get File name. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a13">readMxValues</a> (int col=3)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read matrix of values from file: First two columns are vertices, int col locates the column containing the edge values. </em> <a href="#a13"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a14" doxytag="MatrixOfValues::printMatrix"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a14">printMatrix</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Print matrix of values to standard output. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a15" doxytag="MatrixOfValues::v"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a15">v</a> (int k)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get value of k-th edge. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a16" doxytag="MatrixOfValues::v"></a>
double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a16">v</a> (int i, int j)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get value of edge between i-th and j-th elements. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>double&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a17">v</a> (string a, string b, REDMxVal useRED=useOrgRED)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get value of edge spanned by nodes a and b. </em> <a href="#a17"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a18" doxytag="MatrixOfValues::merge"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a18">merge</a> (<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> *matrix2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge two matrix of values. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a19">merge</a> (<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> *mx2, Partition *pt)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merge two matrix of values and add cluster information for each edge. </em> <a href="#a19"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a20" doxytag="MatrixOfValues::cull"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a20">cull</a> (<a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> *matrix2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cull edges specified in list matrix2. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a21" doxytag="MatrixOfValues::cullEdge"></a>
strpair&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a21">cullEdge</a> (string a, string b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Cull edges spanned by nodes a and b. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a22" doxytag="MatrixOfValues::clusteranalysis"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a22">clusteranalysis</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Analyze cluster. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a23" doxytag="MatrixOfValues::n_edges"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a23">n_edges</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of edges present in the graph. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a24" doxytag="MatrixOfValues::n_items"></a>
long int&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a24">n_items</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the number of items spanning the actual graph. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a25" doxytag="MatrixOfValues::existEdge"></a>
bool&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a25">existEdge</a> (string a, string b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Checks wether the edge was defined or not. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a26" doxytag="MatrixOfValues::W"></a>
edge&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a26">W</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets total sum of edge weights. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top>void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a27">edgeDistribution</a> (const string &amp;sa, int clusterSize=-1, string clusterName="NAN")</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For each node, print distribution of edge weights. Add information of cluster size and name. </em> <a href="#a27"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a28" doxytag="MatrixOfValues::edgeDistribution"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><b>edgeDistribution</b> (Partition *pt=NULL)</td></tr>

<tr><td class="memItemLeft" nowrap align=right valign=top><a class="el" href="classSampling.html">Sampling</a>&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a29">edgeDistributionStats</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get Median, mean, std, var, min and max of all edges. </em> <a href="#a29"></a><em><br><br></td></tr>
<tr><td class="memItemLeft" nowrap align=right valign=top><a name="a30" doxytag="MatrixOfValues::printNodes"></a>
void&nbsp;</td><td class="memItemRight" valign=bottom><a class="el" href="classMatrixOfValues.html#a30">printNodes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">print the nodes of the graph <br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Allows dealing with graphs. A matrix of values here, in each line, specifies an edge value for a given pair of elements . It also allows to merge two such graphs: The output is a pair of values -each from each of provided graphs- for each pair of elements found. This operation has an alternative form where each of these 4-tuples get a label stating the cluster (subfamily) name, if the edge is an intra-cluster edge; x if it's and inter-cluster edge. This requires to provide a partition. This is like coloring the graph. Therefore, the command line option -color. The color can also be NAN1(NAN2) if the first(second) element does not exist in the provided partition. 
<p>
<hr><h2>Member Function Documentation</h2>
<a name="a9" doxytag="MatrixOfValues::cluster"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Partition MatrixOfValues::cluster </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cluster graph. 
<p>
First generate the clusters as ssets (=set)<p>
For each pairs of nodes A and<p>
B<p>
Allocate memory for a new class (A's)<p>
Equivalence class of A gets its inaugural (&amp; representative) member A<p>
If there is no actual edge between A and B<p>
Allocate memory for a new class (B's)<p>
Equivalence class of B gets its inaugural (&amp; representative) member B<p>
Store each member's pointer, which point <p>
to that same class<p>
If there is an actual edge between A and B<p>
and B is in the same class as A<p>
Store each member's pointer, which point <p>
to that same class<p>
Update the list of assigned nodes<p>
else, if B had already been assigned to a class<p>
If there is no actual edge between A and B<p>
Allocate memory for a new class (A's)<p>
Equivalence class of A gets its inaugural (&amp; representative) member A<p>
Store A's own class pointer (pointing to A's class) <p>
If there is an actual edge between A and B<p>
retrieve B's class pointer<p>
and insert A in the same class as B <p>
Store A's class pointer (pointing to A's class) as the same pointer B has<p>
Update the list of assigned nodes<p>
If there is no actual edge between A and B<p>
Allocate memory for a new class (B's)<p>
Equivalence class of B gets its inaugural (&amp; representative) member B<p>
Store B's class pointer (pointing to B's class) as the same pointer A has<p>
If there is an actual edge between A and B<p>
retrieve A's class pointer<p>
and insert B in the same class as A <p>
Store B's class pointer (pointing to B's class) as the same pointer A has<p>
Update the list of assigned clusters<p>
If there is no actual edge between A and B, do nothing, but<p>
If there is an actual edge between A and B<p>
retrieve A's class pointer<p>
retrieve B's class pointer<p>
There shouldn't be any duplicate edge, but just in case, let's not waste resources<p>
merge B into A<p>
Update B's class pointer (pointing to B's class), as well as that of each of its relatives, to the same pointer A has<p>
Delete B's old cluster<p>
Then generate a set of unique sset* pointers. Each point to one of the distinct classes (clusters) defined earlier.<p>
Finally, generate the (fully-sorted) partition and return it as a value<p>
If A hasn't been already assigned to a class, then if B wasn't assigned either<p>
However, if A was already assigned to a class, then if B was not,<p>
else, if B had also been already assigned to a class we need to merge both clusters (A's and B's) if this is an actual edge, so...    </td>
  </tr>
</table>
<a name="a27" doxytag="MatrixOfValues::edgeDistribution"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MatrixOfValues::edgeDistribution </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>sa</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>clusterSize</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>string&nbsp;</td>
          <td class="mdname" nowrap> <em>clName</em> = "NAN"</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
For each node, print distribution of edge weights. Add information of cluster size and name. 
<p>
nan values specify absence of edge; c++, however, treats them as numeric values: We have to take care of that.     </td>
  </tr>
</table>
<a name="a29" doxytag="MatrixOfValues::edgeDistributionStats"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classSampling.html">Sampling</a> MatrixOfValues::edgeDistributionStats </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get Median, mean, std, var, min and max of all edges. 
<p>
nan values specify absence of edge; c++, however, treats them as numeric values: We have to take care of that.     </td>
  </tr>
</table>
<a name="a19" doxytag="MatrixOfValues::merge"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MatrixOfValues::merge </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>mx2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Partition *&nbsp;</td>
          <td class="mdname" nowrap> <em>pt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Merge two matrix of values and add cluster information for each edge. 
<p>
Old version of overlapVspearson-toxmgrace script requires an additional dummy column...to be removed soon...     </td>
  </tr>
</table>
<a name="a8" doxytag="MatrixOfValues::pruneEdges"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classMatrixOfValues.html">MatrixOfValues</a> MatrixOfValues::pruneEdges </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">float&nbsp;</td>
          <td class="mdname" nowrap> <em>edgethreshold</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>long int &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>nedgesdel</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>below</em> = true, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap> <em>terse</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Prunes all edges with weight &lt; threshold if flag is true; &gt; threshold otherwise. 
<p>
If we erase edges we'll lose the singletons. Thus, instead just label those edges as NaN     </td>
  </tr>
</table>
<a name="a13" doxytag="MatrixOfValues::readMxValues"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void MatrixOfValues::readMxValues </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>col</em> = 3          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Read matrix of values from file: First two columns are vertices, int col locates the column containing the edge values. 
<p>
Later on we'll assume _mx represents a square matrix and we don't care about the diagonal values. <p>
Thus input matrix element (i,j) is located at index k=(_nitems-1-i/2)*(i+1)+j-_nitems of vector _mx, where i,j=0,1,2,... and     </td>
  </tr>
</table>
<a name="a17" doxytag="MatrixOfValues::v"></a><p>
<table class="mdTable" width="100%" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> double MatrixOfValues::v </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">string&nbsp;</td>
          <td class="mdname" nowrap> <em>a</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>string&nbsp;</td>
          <td class="mdname" nowrap> <em>b</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>REDMxVal&nbsp;</td>
          <td class="mdname" nowrap> <em>useRED</em> = useOrgRED</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get value of edge spanned by nodes a and b. 
<p>
Should be valid only for the artificially generated duplicates. Care should be taken that it doesn't affect other cases<p>
As we are passing a copy, we can change here a,b without changing the orignal variables. If it's an aritifically generated redundant sequences (-RED-#), use same matrix values as original. Drop substring tail starting at -RED If useOrgRED, matrix value for redundant sequence is that of the original one: IDEAL DUPLICATE. If not, see if useOwnRED: redundant sequences are expected to have their own defined matrix values, e.g., introducing noise on the origingal matrix. if it is useZeroRED, use default edge value (see below) for the redundant sequences. Otherwise, not yet defined. Meanwhile, like useZeroRED.<p>
Using a map with doubles as values (pair of strings as keys) does not allow in an easy way to distinguish between a key with a value=0 or a key that simply was not previously defined. as we are dealing here with graphs, i.e, those keys represent edges, and the values represent numerical weight (and given that I haven't found an easy walkaround) for the time being I'll silently ignore and just print the value for the first key. Still I leave the checking above, otherwise we may assign a zero to an otherwise non-zero edge. cout&lt;&lt;"ERROR in reading matrix "&lt;&lt;_mxofvf&lt;&lt;" : Pair not found "&lt;&lt;a&lt;&lt;" , "&lt;&lt;b&lt;&lt;endl;     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="MatrixOfValues_8h-source.html">MatrixOfValues.h</a><li>MatrixOfValues.cc</ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Feb 12 11:41:56 2010 for Partanalyzer by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.2 </small></address>
</body>
</html>
